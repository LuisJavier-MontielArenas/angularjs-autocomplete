(function(){
  'use strict';
  var $timeout, $filter, $http, $compile;
  var template = '<input /><div></div>';

  var defaultStyle = {
    display:'none', backgroundColor:'#fff', width: '100%',
    position:'absolute', border: '1px solid #ccc', zIndex: 1000,
    margin: 0, paddingLeft: '0.5em', boxSizing: 'border-box'
  };

  var getSourceType = function(source) {
    if (Array.isArray(source) && source[0]) {           // for array source
      return source[0].constructor !== Object ? 1 : 2;  //   1: primitive elements 2: hash elements
    } else if (source.constructor === Object) {         // for hash source
      var firstKey = Object.keys(source)[0];            //   3: primitive value, 4: hash value
      return (typeof source[firstKey] === 'string') ? 3 : 4;
    }
  };

  var showLoading = function(listEl, show) {
    if (!show) {
      listEl.innerHTML = '<div class="loading"> .. Loading </div>'; 
    } else {
      listEl.querySelector('div.loading').remove();
    }
  };

  var addListElements = function(scope, data) {
    var inputEl = scope.inputEl, listEl = scope.listEl;
    var sourceType = getSourceType(data);
    var key, displayText, filteredData;
    //
    //TODO: build a function 'getKeysTexts' 
    //  returns array of {key: 0(or hash key), displayText: displayText} 
    //
    //  then use 'key's to filter to build filteredData
    //
    if (typeof scope.source !== 'string') { // no filter for url source
      filteredData = $filter('filter')(data, scope.keyword);
      console.log('filteredData', filteredData);
    }
    var select = function(key, displayText, obj) {
      return function() { 
        scope.selected = { value: key, text: displayText };
        (obj.constructor == Object) && (scope.selected.object = obj);
        scope.containerEl.controlEl.setOptions(scope.selected);
        scope.valueChanged({value: scope.selected}); //user scope
        //inputEl.value = scope.selected.value;
        scope.ngModel = scope.selected.value;
        scope.$apply();
      };
    };
    while(listEl.firstChild) { 
      listEl.removeChild(listEl.firstChild);
    }
    for (var id in filteredData) {
      var el = filteredData[id];
      if (sourceType == 1) {
        key = el, displayText=el;
      } else if (sourceType == 2) {
        key = el[scope.valueProperty];
        displayText = el[scope.displayProperty];
      } else if (sourceType == 3) {
        key = id, displayText = el;
      } else if (sourceType == 4) {
        key = el[scope.valueProperty] || id;
        displayText = el[scope.displayProperty];
      }
      var liEl = document.createElement('div');
      key && liEl.setAttribute('key', key);
      liEl.innerHTML = displayText;
      liEl.addEventListener('click', select(key, displayText, el));
      listEl.appendChild(liEl);
    }
  };

  var loadList = function(scope, keyword) {
    var inputEl = scope.inputEl, listEl = scope.listEl;
    if (typeof scope.source == 'string') {     // url
       var url= scope.source.replace(/:[a-z]+/i, inputEl.value); 
       showLoading(listEl, true);
       $http.get(url).success(function(data){
         addListElements(scope, data);
         showLoading(listEl, false);
       }).error(function(){
         showLoading(listEl, false);
       });
    } else {
      addListElements(scope, scope.source);
    }
  };

  var addTemplate = function(scope, element, attrs) {
    scope.containerEl = element[0];
    scope.inputEl = document.createElement('input');
    scope.listEl = document.createElement('div');
    scope.inputEl.style.width = '100%';
    scope.inputEl.style.backgroundColor = '#ddd';
    if (attrs.defaultStyle!== 'false') {
      scope.inputEl.style.boxSizing = 'border-box';
      angular.extend(scope.listEl.style, defaultStyle);
    }
    element[0].appendChild(scope.inputEl);
    element[0].appendChild(scope.listEl);
  };

  var linkFunc = function(scope, element, attrs) {
    scope.valueProperty = attrs.valueProperty || 'id';
    scope.displayProperty = attrs.displayProperty || 'value';
    addTemplate(scope, element, attrs);

    scope.inputEl.addEventListener('focus', function() {
      scope.listEl.style.display = 'block';
      scope.keyword = '';
      scope.inputEl.value = '';
      loadList(scope);
    });

    scope.inputEl.addEventListener('blur', function() {
      $timeout(function() {
        scope.listEl.style.display = 'none';
        element[0].style.display = 'none';
      }, 200);
    });

    scope.inputEl.addEventListener('input', function() {
      scope.keyword = scope.inputEl.value;
      loadList(scope);
    });

  };

  var autocompleteDiv =
    function(_$timeout_, _$filter_, _$http_, _$compile_) {
      $timeout = _$timeout_;
      $filter = _$filter_;
      $http = _$http_;
      $compile = _$compile_;

      return {
        restrict: 'E',
        scope: {
          ngModel : '=', 
          source : '=', 
          valueChanged : '&'
        },  //+valueProperty, +displayProperty
        link: linkFunc 
      };
    };

  angular.module('angular-autocomplete').directive('autocompleteDiv', autocompleteDiv);
})();
